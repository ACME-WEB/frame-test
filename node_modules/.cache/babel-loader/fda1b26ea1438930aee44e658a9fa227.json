{"ast":null,"code":"import { useMemo } from 'react';\nimport { getColumnMetrics } from '../utils';\nimport { ValueFormatter } from '../formatters';\nexport function useViewportColumns({\n  rawColumns,\n  columnWidths,\n  viewportWidth,\n  scrollLeft,\n  defaultColumnOptions,\n  rawGroupBy,\n  rowGrouper\n}) {\n  var _a, _b, _c, _d;\n\n  const minColumnWidth = (_a = defaultColumnOptions === null || defaultColumnOptions === void 0 ? void 0 : defaultColumnOptions.minWidth) !== null && _a !== void 0 ? _a : 80;\n  const defaultFormatter = (_b = defaultColumnOptions === null || defaultColumnOptions === void 0 ? void 0 : defaultColumnOptions.formatter) !== null && _b !== void 0 ? _b : ValueFormatter;\n  const defaultSortable = (_c = defaultColumnOptions === null || defaultColumnOptions === void 0 ? void 0 : defaultColumnOptions.sortable) !== null && _c !== void 0 ? _c : false;\n  const defaultResizable = (_d = defaultColumnOptions === null || defaultColumnOptions === void 0 ? void 0 : defaultColumnOptions.resizable) !== null && _d !== void 0 ? _d : false;\n  const {\n    columns,\n    lastFrozenColumnIndex,\n    totalColumnWidth,\n    totalFrozenColumnWidth,\n    groupBy\n  } = useMemo(() => {\n    return getColumnMetrics({\n      rawColumns,\n      minColumnWidth,\n      viewportWidth,\n      columnWidths,\n      defaultSortable,\n      defaultResizable,\n      defaultFormatter,\n      rawGroupBy: rowGrouper ? rawGroupBy : undefined\n    });\n  }, [columnWidths, defaultFormatter, defaultResizable, defaultSortable, minColumnWidth, rawColumns, rawGroupBy, rowGrouper, viewportWidth]);\n  const [colOverscanStartIdx, colOverscanEndIdx] = useMemo(() => {\n    // get the viewport's left side and right side positions for non-frozen columns\n    const viewportLeft = scrollLeft + totalFrozenColumnWidth;\n    const viewportRight = scrollLeft + viewportWidth; // get first and last non-frozen column indexes\n\n    const lastColIdx = columns.length - 1;\n    const firstUnfrozenColumnIdx = Math.min(lastFrozenColumnIndex + 1, lastColIdx); // skip rendering non-frozen columns if the frozen columns cover the entire viewport\n\n    if (viewportLeft >= viewportRight) {\n      return [firstUnfrozenColumnIdx, firstUnfrozenColumnIdx];\n    } // get the first visible non-frozen column index\n\n\n    let colVisibleStartIdx = firstUnfrozenColumnIdx;\n\n    while (colVisibleStartIdx < lastColIdx) {\n      const {\n        left,\n        width\n      } = columns[colVisibleStartIdx]; // if the right side of the columnn is beyond the left side of the available viewport,\n      // then it is the first column that's at least partially visible\n\n      if (left + width > viewportLeft) {\n        break;\n      }\n\n      colVisibleStartIdx++;\n    } // get the last visible non-frozen column index\n\n\n    let colVisibleEndIdx = colVisibleStartIdx;\n\n    while (colVisibleEndIdx < lastColIdx) {\n      const {\n        left,\n        width\n      } = columns[colVisibleEndIdx]; // if the right side of the column is beyond or equal to the right side of the available viewport,\n      // then it the last column that's at least partially visible, as the previous column's right side is not beyond the viewport.\n\n      if (left + width >= viewportRight) {\n        break;\n      }\n\n      colVisibleEndIdx++;\n    }\n\n    const colOverscanStartIdx = Math.max(firstUnfrozenColumnIdx, colVisibleStartIdx - 1);\n    const colOverscanEndIdx = Math.min(lastColIdx, colVisibleEndIdx + 1);\n    return [colOverscanStartIdx, colOverscanEndIdx];\n  }, [columns, lastFrozenColumnIndex, scrollLeft, totalFrozenColumnWidth, viewportWidth]);\n  const viewportColumns = useMemo(() => {\n    const viewportColumns = [];\n\n    for (let colIdx = 0; colIdx <= colOverscanEndIdx; colIdx++) {\n      const column = columns[colIdx];\n      if (colIdx < colOverscanStartIdx && !column.frozen) continue;\n      viewportColumns.push(column);\n    }\n\n    return viewportColumns;\n  }, [colOverscanEndIdx, colOverscanStartIdx, columns]);\n  return {\n    columns,\n    viewportColumns,\n    totalColumnWidth,\n    lastFrozenColumnIndex,\n    totalFrozenColumnWidth,\n    groupBy\n  };\n}","map":null,"metadata":{},"sourceType":"module"}