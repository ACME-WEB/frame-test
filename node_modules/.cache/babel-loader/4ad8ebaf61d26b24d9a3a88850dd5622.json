{"ast":null,"code":"import { useMemo } from 'react';\nconst RENDER_BACTCH_SIZE = 8;\nexport function useViewportRows({\n  rawRows,\n  rowHeight,\n  clientHeight,\n  scrollTop,\n  groupBy,\n  rowGrouper,\n  expandedGroupIds\n}) {\n  const [groupedRows, rowsCount] = useMemo(() => {\n    if (groupBy.length === 0 || !rowGrouper) return [undefined, rawRows.length];\n\n    const groupRows = (rows, [groupByKey, ...remainingGroupByKeys], startRowIndex) => {\n      let groupRowsCount = 0;\n      const groups = {};\n\n      for (const [key, childRows] of Object.entries(rowGrouper(rows, groupByKey))) {\n        // Recursively group each parent group\n        const [childGroups, childRowsCount] = remainingGroupByKeys.length === 0 ? [childRows, childRows.length] : groupRows(childRows, remainingGroupByKeys, startRowIndex + groupRowsCount + 1); // 1 for parent row\n\n        groups[key] = {\n          childRows,\n          childGroups,\n          startRowIndex: startRowIndex + groupRowsCount\n        };\n        groupRowsCount += childRowsCount + 1; // 1 for parent row\n      }\n\n      return [groups, groupRowsCount];\n    };\n\n    return groupRows(rawRows, groupBy, 0);\n  }, [groupBy, rowGrouper, rawRows]);\n  const [rows, allGroupRows] = useMemo(() => {\n    const allGroupRows = new Set();\n    if (!groupedRows) return [rawRows, allGroupRows];\n    const flattenedRows = [];\n\n    const expandGroup = (rows, parentId, level) => {\n      if (Array.isArray(rows)) {\n        flattenedRows.push(...rows);\n        return;\n      }\n\n      Object.keys(rows).forEach((groupKey, posInSet, keys) => {\n        var _a; // TODO: should users have control over the generated key?\n\n\n        const id = parentId !== undefined ? `${parentId}__${groupKey}` : groupKey;\n        const isExpanded = (_a = expandedGroupIds === null || expandedGroupIds === void 0 ? void 0 : expandedGroupIds.has(id)) !== null && _a !== void 0 ? _a : false;\n        const {\n          childRows,\n          childGroups,\n          startRowIndex\n        } = rows[groupKey]; // https://github.com/microsoft/TypeScript/issues/17002\n\n        const groupRow = {\n          id,\n          parentId,\n          groupKey,\n          isExpanded,\n          childRows,\n          level,\n          posInSet,\n          startRowIndex,\n          setSize: keys.length\n        };\n        flattenedRows.push(groupRow);\n        allGroupRows.add(groupRow);\n\n        if (isExpanded) {\n          expandGroup(childGroups, id, level + 1);\n        }\n      });\n    };\n\n    expandGroup(groupedRows, undefined, 0);\n    return [flattenedRows, allGroupRows];\n  }, [expandedGroupIds, groupedRows, rawRows]);\n\n  const isGroupRow = row => allGroupRows.has(row);\n\n  const overscanThreshold = 4;\n  const rowVisibleStartIdx = Math.floor(scrollTop / rowHeight);\n  const rowVisibleEndIdx = Math.min(rows.length - 1, Math.floor((scrollTop + clientHeight) / rowHeight));\n  const rowOverscanStartIdx = Math.max(0, Math.floor((rowVisibleStartIdx - overscanThreshold) / RENDER_BACTCH_SIZE) * RENDER_BACTCH_SIZE);\n  const rowOverscanEndIdx = Math.min(rows.length - 1, Math.ceil((rowVisibleEndIdx + overscanThreshold) / RENDER_BACTCH_SIZE) * RENDER_BACTCH_SIZE);\n  return {\n    rowOverscanStartIdx,\n    rowOverscanEndIdx,\n    rows,\n    rowsCount,\n    isGroupRow\n  };\n}","map":null,"metadata":{},"sourceType":"module"}