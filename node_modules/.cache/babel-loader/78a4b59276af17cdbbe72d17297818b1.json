{"ast":null,"code":"import { ToggleGroupFormatter } from '../formatters';\nimport { SELECT_COLUMN_KEY } from '../Columns';\nexport function getColumnMetrics(metrics) {\n  let left = 0;\n  let totalWidth = 0;\n  let allocatedWidths = 0;\n  let unassignedColumnsCount = 0;\n  let lastFrozenColumnIndex = -1;\n  let totalFrozenColumnWidth = 0;\n  const {\n    rawGroupBy\n  } = metrics;\n  const columns = metrics.rawColumns.map(metricsColumn => {\n    let width = getSpecifiedWidth(metricsColumn, metrics.columnWidths, metrics.viewportWidth);\n\n    if (width === undefined) {\n      unassignedColumnsCount++;\n    } else {\n      width = clampColumnWidth(width, metricsColumn, metrics.minColumnWidth);\n      allocatedWidths += width;\n    }\n\n    const column = { ...metricsColumn,\n      width\n    };\n\n    if (rawGroupBy === null || rawGroupBy === void 0 ? void 0 : rawGroupBy.includes(column.key)) {\n      column.frozen = true;\n      column.rowGroup = true;\n    }\n\n    if (column.frozen) {\n      lastFrozenColumnIndex++;\n    }\n\n    return column;\n  });\n  columns.sort(({\n    key: aKey,\n    frozen: frozenA\n  }, {\n    key: bKey,\n    frozen: frozenB\n  }) => {\n    // Sort select column first:\n    if (aKey === SELECT_COLUMN_KEY) return -1;\n    if (bKey === SELECT_COLUMN_KEY) return 1; // Sort grouped columns second, following the groupBy order:\n\n    if (rawGroupBy === null || rawGroupBy === void 0 ? void 0 : rawGroupBy.includes(aKey)) {\n      if (rawGroupBy.includes(bKey)) {\n        return rawGroupBy.indexOf(aKey) - rawGroupBy.indexOf(bKey);\n      }\n\n      return -1;\n    }\n\n    if (rawGroupBy === null || rawGroupBy === void 0 ? void 0 : rawGroupBy.includes(bKey)) return 1; // Sort frozen columns third:\n\n    if (frozenA) {\n      if (frozenB) return 0;\n      return -1;\n    }\n\n    if (frozenB) return 1; // Sort other columns last:\n\n    return 0;\n  });\n  const unallocatedWidth = metrics.viewportWidth - allocatedWidths;\n  const unallocatedColumnWidth = Math.max(Math.floor(unallocatedWidth / unassignedColumnsCount), metrics.minColumnWidth); // Filter rawGroupBy and ignore keys that do not match the columns prop\n\n  const groupBy = [];\n  const calculatedColumns = columns.map((column, idx) => {\n    var _a, _b, _c, _d, _e; // Every column should have a valid width as this stage\n\n\n    const width = (_a = column.width) !== null && _a !== void 0 ? _a : clampColumnWidth(unallocatedColumnWidth, column, metrics.minColumnWidth);\n    const newColumn = { ...column,\n      idx,\n      width,\n      left,\n      sortable: (_b = column.sortable) !== null && _b !== void 0 ? _b : metrics.defaultSortable,\n      resizable: (_c = column.resizable) !== null && _c !== void 0 ? _c : metrics.defaultResizable,\n      formatter: (_d = column.formatter) !== null && _d !== void 0 ? _d : metrics.defaultFormatter\n    };\n\n    if (newColumn.rowGroup) {\n      groupBy.push(column.key);\n      newColumn.groupFormatter = (_e = column.groupFormatter) !== null && _e !== void 0 ? _e : ToggleGroupFormatter;\n    }\n\n    totalWidth += width;\n    left += width;\n    return newColumn;\n  });\n\n  if (lastFrozenColumnIndex !== -1) {\n    const lastFrozenColumn = calculatedColumns[lastFrozenColumnIndex];\n    lastFrozenColumn.isLastFrozenColumn = true;\n    totalFrozenColumnWidth = lastFrozenColumn.left + lastFrozenColumn.width;\n  }\n\n  return {\n    columns: calculatedColumns,\n    lastFrozenColumnIndex,\n    totalFrozenColumnWidth,\n    totalColumnWidth: totalWidth,\n    groupBy\n  };\n}\n\nfunction getSpecifiedWidth({\n  key,\n  width\n}, columnWidths, viewportWidth) {\n  if (columnWidths.has(key)) {\n    // Use the resized width if available\n    return columnWidths.get(key);\n  }\n\n  if (typeof width === 'number') {\n    return width;\n  }\n\n  if (typeof width === 'string' && /^\\d+%$/.test(width)) {\n    return Math.floor(viewportWidth * parseInt(width, 10) / 100);\n  }\n\n  return undefined;\n}\n\nfunction clampColumnWidth(width, {\n  minWidth,\n  maxWidth\n}, minColumnWidth) {\n  width = Math.max(width, minWidth !== null && minWidth !== void 0 ? minWidth : minColumnWidth);\n\n  if (typeof maxWidth === 'number') {\n    return Math.min(width, maxWidth);\n  }\n\n  return width;\n} // Logic extented to allow for functions to be passed down in column.editable\n// this allows us to decide whether we can be editing from a cell level\n\n\nexport function canEdit(column, row) {\n  var _a, _b;\n\n  if (typeof column.editable === 'function') {\n    return column.editable(row);\n  }\n\n  return Boolean((_b = (_a = column.editor) !== null && _a !== void 0 ? _a : column.editor2) !== null && _b !== void 0 ? _b : column.editable);\n}\nexport function getColumnScrollPosition(columns, idx, currentScrollLeft, currentClientWidth) {\n  let left = 0;\n  let frozen = 0;\n\n  for (let i = 0; i < idx; i++) {\n    const column = columns[i];\n\n    if (column) {\n      if (column.width) {\n        left += column.width;\n      }\n\n      if (column.frozen) {\n        frozen += column.width;\n      }\n    }\n  }\n\n  const selectedColumn = columns[idx];\n\n  if (selectedColumn) {\n    const scrollLeft = left - frozen - currentScrollLeft;\n    const scrollRight = left + selectedColumn.width - currentScrollLeft;\n\n    if (scrollLeft < 0) {\n      return scrollLeft;\n    }\n\n    if (scrollRight > currentClientWidth) {\n      return scrollRight - currentClientWidth;\n    }\n  }\n\n  return 0;\n}","map":null,"metadata":{},"sourceType":"module"}